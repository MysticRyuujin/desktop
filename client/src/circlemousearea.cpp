// Copyright (c) 2025 Private Internet Access, Inc.
//
// This file is part of the Private Internet Access Desktop Client.
//
// The Private Internet Access Desktop Client is free software: you can
// redistribute it and/or modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation, either version 3 of
// the License, or (at your option) any later version.
//
// The Private Internet Access Desktop Client is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with the Private Internet Access Desktop Client.  If not, see
// <https://www.gnu.org/licenses/>.

#include <common/src/common.h>
#line SOURCE_FILE("circlemousearea.cpp")

#include "circlemousearea.h"

#include <QCursor>


CircleMouseArea::CircleMouseArea()
    : _containsMouse{false}, _pressed{false},
      _cursorShape{Qt::CursorShape::ArrowCursor}
{
    setAcceptedMouseButtons(Qt::MouseButton::LeftButton);
    setAcceptHoverEvents(true);
}

void CircleMouseArea::setCursorShape(Qt::CursorShape newCursorShape)
{
    if(_cursorShape == newCursorShape)
        return; // No change, nothing to do

    _cursorShape = newCursorShape;
    // If the cursor is currently over the circle, update the cursor
    if(containsMouse())
        setCursor(_cursorShape);
    emit cursorShapeChanged();
}

bool CircleMouseArea::pointInCircle(const QPointF &pos)
{
    // Get this item's bound
    QRectF bound{x(), y(), width(), height()};

    // Find the circle's radius, which is controlled by the smaller of width or
    // height
    qreal radius = std::min(bound.width(), bound.height()) * 0.5;

    // Find the center of the bound
    QPointF center = bound.center();

    // Find the squared distance from the point to the center
    QPointF posFromCenter = pos - center;
    qreal squaredDist = QPointF::dotProduct(posFromCenter, posFromCenter);

    // If the distance is not greater than the radius, the point is inside the
    // circle
    return squaredDist <= (radius * radius);
}

bool CircleMouseArea::updateCursor(const QPointF &currentCursorPos)
{
    bool inCircle = pointInCircle(currentCursorPos);
    if(inCircle)
        setCursor(QCursor{_cursorShape});
    else
        unsetCursor();

    return inCircle;
}

void CircleMouseArea::handleHoverEvent(QHoverEvent *event)
{
    Q_ASSERT(event);

    bool inCircle = updateCursor(event->position());
    updateContainsMouse(inCircle);

    // It doesn't matter whether we accept these events; hover events are
    // propagated regardless of acceptance.
    event->accept();
}

void CircleMouseArea::updateContainsMouse(bool newContainsMouse)
{
    if(_containsMouse == newContainsMouse)
        return; // No change, nothing to do

    bool oldContainsPress = containsPress();
    _containsMouse = newContainsMouse;
    emit containsMouseChanged();
    if(oldContainsPress != containsPress())
        emit containsPressChanged();
}

void CircleMouseArea::updatePressed(bool newPressed)
{
    if(_pressed == newPressed)
        return; // No change, nothing to do

    bool oldContainsPress = containsPress();
    _pressed = newPressed;
    emit pressedChanged();
    if(oldContainsPress != containsPress())
        emit containsPressChanged();
}

void CircleMouseArea::hoverEnterEvent(QHoverEvent *event)
{
    handleHoverEvent(event);
}

void CircleMouseArea::hoverLeaveEvent(QHoverEvent *event)
{
    Q_ASSERT(event);
    // A hover-leave event does not have a meaningful position (it's always
    // (-1, -1)), but we know the cursor is outside of the circle.
    unsetCursor();
    updateContainsMouse(false);
    event->accept();
}

void CircleMouseArea::hoverMoveEvent(QHoverEvent *event)
{
    handleHoverEvent(event);
}

void CircleMouseArea::mouseMoveEvent(QMouseEvent *event)
{
    // Note that this event is only generated by Qt when a prior button press
    // occurred on this control (mousePressEvent()).
    //
    // We still always accept this event, since this item is currently receiving
    // all cursor input.
    Q_ASSERT(event);
    bool inCircle = updateCursor(event->position());
    updateContainsMouse(inCircle);

    event->accept();
}

void CircleMouseArea::mousePressEvent(QMouseEvent *event)
{
    Q_ASSERT(event);

    // Note that we only accept one button (Qt::LeftButton), so we don't have to
    // check or store the button that was pressed.

    // Accept the event only if the cursor is actually inside the circle
    bool inCircle = updateCursor(event->position());
    updatePressed(inCircle);
    event->setAccepted(inCircle);
}

void CircleMouseArea::mouseReleaseEvent(QMouseEvent *event)
{
    Q_ASSERT(event);

    // Qt only generates this event if a prior button press occurred on this
    // control, and we only accept one button, so we just have to check whether
    // the cursor is inside the circle.
    bool inCircle = updateCursor(event->position());
    updatePressed(false);
    // Always accept this event, since this item is receiving all cursor input
    // anyway.
    event->accept();

    // Emit the clicked signal only if the cursor was in the circle for the
    // release.
    if(inCircle)
        emit clicked();
}

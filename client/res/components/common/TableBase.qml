// Copyright (c) 2022 Private Internet Access, Inc.
//
// This file is part of the Private Internet Access Desktop Client.
//
// The Private Internet Access Desktop Client is free software: you can
// redistribute it and/or modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation, either version 3 of
// the License, or (at your option) any later version.
//
// The Private Internet Access Desktop Client is distributed in the hope that
// it will be useful, but WITHOUT ANY WARRANTY; without even the implied
// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with the Private Internet Access Desktop Client.  If not, see
// <https://www.gnu.org/licenses/>.

import QtQuick 2.9
import QtQuick.Controls 2.3
import "../core"
import "../theme"
import PIA.NativeAcc 1.0 as NativeAcc
import "qrc:/javascript/keyutil.js" as KeyUtil
import "qrc:/javascript/util.js" as Util

// Defines the basic functionality for tables in PIA, which includes:
// - the scroll view containing the items
// - keyboard navigation models
// - accessibility models
Rectangle {
  id: tableBase

  color: Theme.settings.hbarBackgroundColor
  border.color: Theme.settings.hbarBottomBorderColor
  border.width: 1
  activeFocusOnTab: true

  // Label used for the table's own accessibility annotations
  property string label

  // Scroll bar policy for the vertical scroll bar
  property int verticalScrollPolicy
  // Content width and height - defaults to the parent's size, determines the
  // scroll limits.  Typically, when placing a ColumnLayout inside the table,
  // bind the content height to the layout's implicit height.
  property int contentWidth: tableBase.width
  property int contentHeight: tableBase.height
  property bool hideTableFocusCue: false

  // Contents are placed inside the scroll view's Flickable
  default property alias listContent: scrollViewContent.data

  // Focus a cell in the table that was selected with the mouse.
  function mouseFocusCell(row, column) {
    keyboardRow = row
    keyboardColumn = column
    tableBase.forceActiveFocus(Qt.MouseFocusReason)
  }

  // Number of keyboard columns in this table (must not change once bound, used
  // by keyboard event handlers)
  property int keyboardColumnCount

  // Accessibility column definitions.  This is passed through to
  // NativeAcc.Table.columns, with the additional requirement that 'property'
  // must also name a property of the TableRow objects containing that cell's
  // accessibility definition.
  //
  // For example, in the split tunnel app list, each app row has an "App" cell.
  // The SplitTunnelAppRow object defines an "accAppCell" property containing a
  // NativeAcc.TableCellText definition.
  //
  // Note that in some cases, the accessibility columns may differ from the
  // keyboard columns (split tunnel models a "path" column for accessibility but
  // includes it in the "app" column for keyboard nav).
  property var accColumns

  // Map a keyboard column to an accessibility column, used for
  // NativeAcc.Table.navigateCol.  The default is an identity function, which
  // makes sense if the column models are the same.
  //
  // If they are not the same, override this with a function that maps the
  // columns correctly.
  property var accColumnForKeyColumn: function(column){return column}

  // === Accessibility Table, Keyboard Row/Column ===
  // Tables in PIA Desktop use an "accessibility table" model for keyboard
  // navigation and accessibility.  The accessibility table consists of row
  // objects that describe each row in the list.
  //
  // The current keyboard cell is described by a "keyboard row" and "keyboard
  // column".  The keyboard row is a string identifying a row in the list.
  //
  // Keyboard row identifiers are usually of the form "<type>/<value>" but can
  // be of any form determined by the table list.  (Some table lists previously
  // used objects with multiple properties to identify rows, but the NativeAcc
  // table annotations require a single string ID anyway.)
  //
  // The keyboard column is an integer index in the range of columns in the
  // table.
  //
  // The keyboard row is described with a row identifier, not an index, in order
  // to handle changes to the list - the selection is preserved if other items
  // in the list are added or removed, or if the order of items in the list
  // changes (like re-sorting the regions list).

  // Accessibility table generated by the specific table implementation.
  // Bindings to this property typically build a table row for each row
  // presented.  (If you enumerate a repeater's children with count/itemAt(),
  // remember to add an explicit dependency on the 'children' property too.)
  //
  // Each row must have:
  // - row - a row identifier string (most tables use the form "<type>/<value>",
  //   such as "ip/172.16.0.0/12", "app//usr/bin/curl", "add/", etc.)
  // - item - a TableRowBase item defining the bounds of that row (used to
  //   scroll the row into view for key events, and to call keyboardSelect())
  // - name - the display name for this row used for keyboard navigation with
  //   letter keys
  property var accTable

  // Cell selected by keyboard.  The table should bind keyboardRow by default to
  // the value representing the first row, which is typically an "add item" row
  // or some other special row.
  property string keyboardRow
  property int keyboardColumn: 0
  // If there's a highlight cell, this is the highlighted column within the
  // keyboard cell.  (There's no highlight cell when focus cues are hidden, but
  // there is always a keyboard cell.)
  property int highlightColumn: focusCue.show ? keyboardColumn : -1

  // Build a row identifier using the typical "<type>/<value>" format.  The
  // table doesn't have to use this format, but it works for most tables.
  // value can contain any characters (including slashes), but type should be
  // alphanumeric.  value defaults to "" if omitted.
  //
  // Tables shouldn't have to split these values, they're just built as
  // identifiers to indicate rows.  Typically an identifier is compared to a
  // specific row by building an identifier and comparing the result.
  function buildRowId(type, value) {
    return type + "/" + (value || "")
  }

  // Find the current index of keyboardRow in accTable, or -1 if it's not present
  function findAccKeyboardIndex() {
    return accTable.findIndex(function(row) {return row.row === keyboardRow})
  }

  // If the accessibility table changes, and the current keyboard row is
  // removed, select another row
  property var lastAccTable: []
  onAccTableChanged: {
    var newKeyboardRow = KeyUtil.updateAccKeyboardRow(accTable, lastAccTable,
                                                      keyboardRow)
    if(newKeyboardRow !== keyboardRow) {
      keyboardRow = newKeyboardRow
    }

    lastAccTable = accTable
  }

  // Scroll view containing the list's content.  Children of TableBase are
  // placed inside the Flickable.  Normally the table will create a ColumnLayout
  // with a Repeater inside (and usually fixed items also), but the table can
  // position the items any way it wants.
  ThemedScrollView {
    id: scrollView
    ScrollBar.vertical.policy: tableBase.verticalScrollPolicy
    label: tableBase.label
    anchors.fill: parent
    contentWidth: tableBase.contentWidth
    contentHeight: tableBase.contentHeight
    clip: true

    Flickable {
      id: scrollViewFlickable
      boundsBehavior: Flickable.StopAtBounds
      // Never a tab stop, scroll with keyboard nav from the list
      activeFocusOnTab: false

      // Making the Flickable's data property the default for TableBase doesn't
      // work - the items aren't re-parented to the contentItem.
      // Setting the contentItem's data property to the default doesn't work
      // either, because the content item isn't created yet when the aliases are
      // checked.
      // Create an actual item inside here to contain the table contents.
      Item {
        id: scrollViewContent
        width: tableBase.contentWidth
        height: tableBase.contentHeight
      }
    }
  }

  property var inKeyPress: null

  Keys.onPressed: {
    // Find the index of the current keyboard row (-1 if none)
    var keyboardIdx = findAccKeyboardIndex()

    var nextIdx = -1
    // Check for an 'accept' key
    if(KeyUtil.handleButtonKeyEvent(event)) {
      inKeyPress = event.key
      // Row might not change, but still reveal it
      nextIdx = keyboardIdx
    }
    // Left and Right just move columns - other navigation keys navigate rows
    else if(event.key === Qt.Key_Left) {
      keyboardColumn = Math.max(0, keyboardColumn-1)
      event.accepted = true
      nextIdx = keyboardIdx  // Row doesn't change, but still reveal it
    }
    else if(event.key === Qt.Key_Right) {
      keyboardColumn = Math.min(keyboardColumnCount-1, keyboardColumn+1)
      event.accepted = true
      nextIdx = keyboardIdx
    }
    else {
      nextIdx = KeyUtil.handleVertKeyEvent(event, accTable, 'name',
                                           keyboardIdx)
    }

    // If this wasn't a key event we understood, don't do anything else.
    if(nextIdx === -1)
      return

    // Find the new row and update keyboardRow
    var newKeyboardRow = accTable[nextIdx]
    keyboardRow = newKeyboardRow.row
    // Reveal the focus cue for the whole list
    focusCue.reveal()
    // Reveal the current row
    var bound = newKeyboardRow.item.mapToItem(scrollViewFlickable.contentItem,
                                              0, 0, newKeyboardRow.item.width,
                                              newKeyboardRow.item.height)
    Util.ensureScrollViewVertVisible(scrollView, scrollView.ScrollBar.vertical,
                                     bound.y, bound.height)
  }

  Keys.onReleased: {
    if(inKeyPress && inKeyPress === event.key) {
      event.accepted = true
      inKeyPress = null
      // Activate the current cell
      var keyboardIdx = findAccKeyboardIndex()
      var currentRow = accTable[keyboardIdx]
      if(currentRow && currentRow.item) {
        currentRow.item.keyboardSelect(keyboardColumn)
      }
    }
  }

  onActiveFocusChanged: {
    if(!activeFocus)
      inKeyPress = null
  }

  OutlineFocusCue {
    id: focusCue
    anchors.fill: parent
    control: tableBase
    // Fade - the rows/cells also show a focus cue
    opacity: hideTableFocusCue ? 0 : 0.6
  }

  NativeAcc.Table.name: label

  NativeAcc.Table.columns: accColumns
  NativeAcc.Table.rows: {
    var tblRows = []

    var accRow, rowObj
    for(var i=0; i<accTable.length; ++i) {
      accRow = accTable[i]
      rowObj = {id: accRow.row, row: accRow.item.accRow}
      // Copy each cell definition from the TableRow item to the row object
      // passed to NativeAcc
      for(var j=0; j<accColumns.length; ++j) {
        rowObj[accColumns[j].property] = accRow.item[accColumns[j].property]
      }
      tblRows.push(rowObj)
    }

    return tblRows
  }

  NativeAcc.Table.navigateRow: findAccKeyboardIndex()
  NativeAcc.Table.navigateCol: {
    var keyboardIdx = findAccKeyboardIndex()
    var keyboardRow = accTable[keyboardIdx] // undefined if idx==-1
    if(!keyboardRow)
      return -1
    var effectiveKeyCol = keyboardRow.item.effectiveColumnFor(keyboardColumn)
    return accColumnForKeyColumn(effectiveKeyCol)
  }
}
